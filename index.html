<!DOCTYPE html>
<html>
  <head>
    <title>Type Classes from the Ground Up</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
  </head>
  <body>
      <textarea id="source">
class: center, middle

# Type Classes from the Ground Up

Nicolas Rinaudo â€¢ [`@NicolasRinaudo`](https://twitter.com/NicolasRinaudo) â€¢ [ioSquare](http://iosquare.com)

---

## Goals

* Understand what purpose type classes serve
* Get a feel for  implicit composition

--

## Running example: CSV parser

CSV data is composed of rows and columns

```csv
1,Nicolas,Rinaudo
2,Jessica,Jones
3,Matt,Murdock
```

---

## Simple CSV parser

```scala
def parseCsv(input: String): List[List[String]] =
  input.split('\n').toList.map(_.split(",").toList)
```

We purposefully ignore the following flaws:

* cannot handle "complex" CSV data
* inefficient, both in terms of CPU and memory

---

## Basic example: raw numbers

```scala
scala> val input = "1,2,3\n4,5,6\n7,8,9"
input: String =
1,2,3
4,5,6
7,8,9
```

--

Running the parser yields:

```scala
scala> parseCsv(input)
res0: List[List[String]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

--

Representing clear numeric values as `String`s is unsatisfactory.

---

## Improvement: mapping to `Int`

```scala
scala> parseCsv(input).map(_.map(_.toInt))
res1: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

--

Not very practical: you have to manually parse `Int`s every time.

---

## Decoding CSV: first attempt

Usual answer to making reusable code: Î»-functions

```scala
def decodeCsv[A](input: String)(f: String â‡’ A): List[List[A]] =
  parseCsv(input).map(_.map(f))
```

--

Running the decoder yields:

```scala
scala> decodeCsv(input)(_.toInt)
res2: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

--

Better, but not great: you have to explicitly specify how to decode types every time.

---

## Small detour: implicits

> When a function expects a parameter of type `T` _and_ that parameter is marked as implicit _and_ there exists a
> value of type `T` marked as implicit in scope, then the compiler can use that value automatically.

--

Example:

```scala
implicit val a: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

--

Running `printInt` without a parameter:

```scala
scala> printInt
2
```

---

## Decoding CSV with implicits

Declare an implicit decoding function parameter:

```scala
def decodeCsv[A](input: String)
                (implicit f: String â‡’ A): List[List[A]] =
  parseCsv(input).map(_.map(f))

implicit val strToInt: String â‡’ Int = Integer.parseInt
```

--

Running the decoder without a decoding function yields:

```scala
scala> decodeCsv[Int](input)
res6: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## The dangers of implicits

> When the compiler finds a type `S` where it expects a type `T`, but there exists an implicit `S` â‡’ `T`
> in scope, it will be applied silently.

This is called implicit conversions and is generally accepted as not a good thing _for the most part_.

--

```scala
scala> def add1(i: Int): Int = i + 1
add1: (i: Int)Int

scala> add1("123")
res7: Int = 124
```

---

## Finally: type classes

To avoid pluging into the implicit conversion mechanism, declare a dedicated type:

```scala
trait CellDecoder[T] {
  def decode(s: String): T
}

implicit val intDecoder: CellDecoder[Int] = new CellDecoder[Int] {
  override def decode(s: String) = s.toInt
}
```

---

## Type class backed decoder

We can now rewrite `decodeCsv`:

```scala
def decodeCsv[A](input: String)
                (implicit da: CellDecoder[A]): List[List[A]] =
  parseCsv(input).map(_.map(da.decode))
```

--

And run it as expected:

```scala
scala> decodeCsv[Int](input)
res9: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## Enhancement without inheritance!

Important realisation: _we've added a new feature to `Int`, even though it's `final`_.

--

Think about implementing the same with subtyping:

* create a `Decodable` interface.

--

* have `Int` implement `Decodable`.

--

* but `Int` is final...

--

* create... `WrappedInt` that implements `Decodable` and proxies all calls to `Int`?

--

* ðŸ˜±


---

## Heterogenous types

`decodeCsv` can decode our input. But what about:

```scala
scala> val input = "1,Nicolas\n2,Jessica\n3,Matt"
input: String =
1,Nicolas
2,Jessica
3,Matt
```

--

This could be decoded as a `(Int, String)`.

Problem: we only know how to decode rows of homogenous types.

---

## `RowDecoder` type class

We need a decoder type class for rows:

```scala
trait RowDecoder[T] {
  def decode(ss: List[String]): T
}
```

--

`decodeCsv` now looks like:

```scala
def decodeCsv[A](input: String)
                (implicit da: RowDecoder[A]): List[A] =
  parseCsv(input).map(da.decode)
```

---

## First, a bit of plumbing

Let's make instance creation less of a pain:

```scala
def cellDecoder[A](f: String â‡’ A) = new CellDecoder[A] {
  override def decode(s: String) = f(s)
}

def rowDecoder[A](f: List[String] â‡’ A) = new RowDecoder[A] {
  override def decode(ss: List[String]) = f(ss)
}

```

--

Also, create a bunch of useful `CellDecoder` instances:

```scala
implicit val intDecoder     = cellDecoder(_.toInt)
implicit val floatDecoder   = cellDecoder(_.toFloat)
implicit val stringDecoder  = cellDecoder(identity)
implicit val booleanDecoder = cellDecoder(_.toBoolean)
```

---

## First attempt at decoding tuples

```scala
implicit val decoder = rowDecoder(row â‡’ (row(0).toInt, row(1)))
```

--

This works:

```scala
scala> decodeCsv[(Int, String)](input)
res12: List[(Int, String)] = List((1,Nicolas), (2,Jessica), (3,Matt))
```

--

Disapointing, though: parsing of individual cells is hard-coded.

Didn't we just write a mechanism for that?

---

## Using `CellDecoder`, take 1

Naive implementation:

```scala
implicit val decoder = rowDecoder { row â‡’
  (intDecoder.decode(row(0)),
   stringDecoder.decode(row(1)))
}
```

--

The decoder instances are hard-coded - always a sign that things can be made more generic.

---

## Another look at implicit resolution

There's another rule used in implicit resolution:

> When the compiler looks for an implicit values of type `T` and finds a function that returns a `T` that it can call,
> it will use its return value.

Of interest to us: a function that returns a `T` and that takes implicit parameters that can all be fulfilled.

---

## Using `CellDecoder`, take 2

Better implementation:

```scala
implicit def decoder(implicit di: CellDecoder[Int],
                              ds: CellDecoder[String]) =
  rowDecoder(row â‡’ (di.decode(row(0)), ds.decode(row(1))))
```

--

This produces the desired result:

```scala
scala> decodeCsv[(Int, String)](input)
res13: List[(Int, String)] = List((1,Nicolas), (2,Jessica), (3,Matt))
```

--

It works because, when looking for an implicit `RowDecoder[(Int, String)]`, the compiler finds `decoder`, and
realises it can call it.

---

## Using `CellDecoder`, take 3

Why specialise our implicit parameters to `Int` and `String`?

```scala
implicit def decoder[A, B](implicit da: CellDecoder[A],
                                    db: CellDecoder[B]) =
  rowDecoder(row â‡’ (da.decode(row(0)), db.decode(row(1))))
```

--

Take a minute to let that sink in:

_We've written an instance of `RowDecoder[(A, B)]` for all `A` and `B` that have a `CellDecoder` instance_.

--

For example:

```scala
scala> decodeCsv[(Float, String)](input)
res14: List[(Float, String)] = List((1.0,Nicolas), (2.0,Jessica), (3.0,Matt))
```

---

## Optional cells

Sometimes, CSV cells are absent or empty:

```scala
scala> val input = "1,Nicolas\n,Jessica\n3,Matt"
input: String =
1,Nicolas
,Jessica
3,Matt
```

--

This is what `Option` is made for.

```scala
implicit def optionCellDecoder[A](implicit da: CellDecoder[A]) = cellDecoder {
  case "" â‡’ None
  case s  â‡’ Some(da.decode(s))
}
```

---

## Optional cells (2)

This yields the expected result:

```scala
scala> decodeCsv[(Option[Int], String)](input)
res15: List[(Option[Int], String)] = List((Some(1),Nicolas), (None,Jessica), (Some(3),Matt))
```

--

_We've written an instance of `CellDecoder[Option[A]]` for all `A` that have a `CellDecoder` instance._

---

## Cells with multiple types

"Sometimes", CSV data is messy:

```scala
scala> val input = "1,Nicolas\ntrue,Jessica"
input: String =
1,Nicolas
true,Jessica
```

--

We have `Either` to represent these cases:

```scala
implicit def eitherCellDecoder[A, B](implicit da: CellDecoder[A],
                                              db: CellDecoder[B]) =
  cellDecoder { s â‡’
    try { Left(da.decode(s)) }
    catch { case _: Throwable â‡’ Right(db.decode(s)) }
  }
```

---

## Cells with multiple types (2)

This yields the expected result:

```scala
scala> decodeCsv[(Either[Int, Boolean], String)](input)
res16: List[(Either[Int,Boolean], String)] = List((Left(1),Nicolas), (Right(true),Jessica))
```

--

_We've written an instance of `CellDecoder[Either[A, B]]` for all `A` and `B` that have a `CellDecoder` instance._

---

## Complex compositions

```scala
scala> val input = "1,Nicolas\nfalse,Jessica\n,Matt"
input: String =
1,Nicolas
false,Jessica
,Matt
```

The first column looks like an `Option[Either[Int, Boolean]]`.

--

We already have `Either` and `Option` instances, so we get this for free:

```scala
scala> decodeCsv[(Option[Either[Int, Boolean]], String)](input)
res17: List[(Option[Either[Int,Boolean]], String)] = List((Some(Left(1)),Nicolas), (Some(Right(false)),Jessica), (None,Matt))
```



---

## Collections of values

We have lost the ability to decode a row as `List[Int]` on the way:

```scala
val input = "1,2,3\n4,5,6\n7,8,9"
```

--

Warning - uses `CanBuildFrom`

--

```scala
import scala.collection.generic.CanBuildFrom

implicit def collectionDecoder[A, C[_]]
               (implicit da: CellDecoder[A],
                         cbf: CanBuildFrom[Nothing, A, C[A]]) =
  rowDecoder(_.foldLeft(cbf.apply()) { (out, s) â‡’
    out += da.decode(s)
  }.result())
```

---

## Collections of values (2)

This yields the expected result, for any collection type:

```scala
scala> decodeCsv[List[Int]](input)
res19: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

```scala
scala> decodeCsv[Vector[Int]](input)
res20: List[Vector[Int]] = List(Vector(1, 2, 3), Vector(4, 5, 6), Vector(7, 8, 9))
```

```scala
scala> decodeCsv[Array[Int]](input)
res21: List[Array[Int]] = List(Array(1, 2, 3), Array(4, 5, 6), Array(7, 8, 9))
```

--

_We've written an instance of `RowDecoder[F[A]]` for any collection `F` and any `A` that has a `CellDecoder` instance._

---

## Case classes

We *could* write a `RowDecoder[A]` instance for any case class `A`â€¦

--

â€¦ but I'd have to use [shapeless](http://shapeless.io), and this would turn into a different talk entirely.

---

## Conclusions

Type classes:
* are great at adding new features to existing types

```scala
implicit val uuidDecoder = cellDecoder(java.util.UUID.fromString)
```

--

* compose implicitly, without having to write any type specific code

```scala
scala> implicitly[RowDecoder[List[Either[Int, Option[Either[Boolean, java.util.UUID]]]]]]
res22: RowDecoder[List[Either[Int,Option[Either[Boolean,java.util.UUID]]]]] = $anon$1@61db3f4a
```

---

## More information

Find me on Twitter ([`@NicolasRinaudo`](https://twitter.com/NicolasRinaudo)).

Make fun of my code on Github ([`nrinaudo`](https://github.com/nrinaudo/)).

See [kantan.csv](http://nrinaudo.github.io/kantan.csv/) for a concrete, usable implementation.

Get in touch with [`ioSquare`](http://iosquare.com), we're always on the lookout for Scala talent.




---
class: center, middle

# Thanks!

    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
        highlightStyle: 'solarized-dark'
      });
    </script>
  </body>
</html>
