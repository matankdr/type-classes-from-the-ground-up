<!DOCTYPE html>
<html>
  <head>
    <title>Type Classes from the Ground Up</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
  </head>
  <body>
      <textarea id="source">
class: center, middle

# Type Classes from the Ground Up

Nicolas Rinaudo • [`@NicolasRinaudo`](https://twitter.com/NicolasRinaudo) • [ioSquare](http://iosquare.com)

---

## Goals

* Understand what purpose type classes serve
* Get a feel for  implicit composition

--

## Running example: CSV parser

CSV data is composed of rows and columns

```csv
1,Nicolas,Rinaudo
2,Jessica,Jones
3,Matt,Murdock
```

---

## Simple CSV parser

```scala
def parseCsv(input: String): List[List[String]] =
  input.split('\n').toList.map(_.split(",").toList)
```

We purposefully ignore the following flaws:

* cannot handle "complex" CSV data
* inefficient, both in terms of CPU and memory

---

## Basic example: raw numbers

```scala
val input = "1,2,3\n4,5,6\n7,8,9"
```

--

Running the parser yields:

```scala
scala> parseCsv(input)
res0: List[List[String]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

--

Representing clear numeric values as `String`s is unsatisfactory.

---

## Improvement: mapping to `Int`

```scala
scala> parseCsv(input).map(_.map(_.toInt))
res1: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

--

Not very practical: you have to manually parse `Int`s every time.

---

## Decoding CSV: first attempt

Usual answer to making reusable code: λ-functions

```scala
def decodeCsv[A](input: String)(f: String ⇒ A): List[List[A]] =
  parseCsv(input).map(_.map(f))
```

--

Running the decoder yields:

```scala
scala> decodeCsv(input)(_.toInt)
res2: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

--

Better, but not great: you have to explicitly specify how to decode types every time.

---

## Small detour: implicits

> When a function expects a parameter of type `T`, that parameter is marked as implicit and there exists a value of
> type `T` marked as implicit in scope, then the compiler can use that value automatically.

--

Example:

```scala
implicit val a: Int = 2

def printInt(implicit i: Int): Unit = println(i)
```

--

Running `printInt` without a parameter:

```scala
scala> printInt
2
```

---

## Decoding CSV with implicits

Declare an implicit decoding function parameter:

```scala
def decodeCsv[A](input: String)
                (implicit f: String ⇒ A): List[List[A]] =
  parseCsv(input).map(_.map(f))

implicit val strToInt: String ⇒ Int = Integer.parseInt
```

--

Running the decoder without a decoding function yields:

```scala
scala> decodeCsv[Int](input)
res6: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## The dangers of implicits

> When the compiler finds a type `S` where it expects a type `T`, but there exists an implicit function from `S` to
> `T` in scope, it will be applied silently.

This is called implicit conversions and is generally accepted as not a good thing _for the most part_.

--

```scala
scala> def add1(i: Int): Int = i + 1
add1: (i: Int)Int

scala> add1("123")
res7: Int = 124
```

---

## Finally: type classes

To avoid pluging into the implicit conversion mechanism, declare a dedicated type:

```scala
trait CellDecoder[T] {
  def decode(s: String): T
}

implicit val intDecoder: CellDecoder[Int] = new CellDecoder[Int] {
  override def decode(s: String) = s.toInt
}
```

---

## Type class backed decoder

We can now rewrite `decodeCsv`:

```scala
def decodeCsv[A](input: String)
                (implicit da: CellDecoder[A]): List[List[A]] =
  parseCsv(input).map(_.map(da.decode))
```

--

And run it as expected:

```scala
scala> decodeCsv[Int](input)
res9: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

---

## Enhancement without inheritance!

Important realisation: _we've added a new feature to `Int`, even though it's `final`_.

Type classes allow us to extend existing types without subtyping them.


---

## Heterogenous types

`decodeCsv` can decode our input. But what about:

```scala
scala> val input = "1,Nicolas,true\n2,Jessica,false\n3,Matt,false"
input: String =
1,Nicolas,true
2,Jessica,false
3,Matt,false
```

--

This could be decoded as a `(Int, String, Boolean)`.

Problem: we only know how to decode rows of homogenous types.

---

## `RowDecoder` type class

We need a decoder type class for rows:

```scala
trait RowDecoder[T] {
  def decode(ss: List[String]): T
}
```

--

`decodeCsv` now looks like:

```scala
def decodeCsv[A](input: String)
                (implicit da: RowDecoder[A]): List[A] =
  parseCsv(input).map(da.decode)
```

---

## First, a bit of plumbing

Let's make instance creation less of a pain:

```scala
def cellDecoder[A](f: String ⇒ A) = new CellDecoder[A] {
  override def decode(s: String) = f(s)
}

def rowDecoder[A](f: List[String] ⇒ A) = new RowDecoder[A] {
  override def decode(ss: List[String]) = f(ss)
}

```

--

Also, create a bunch of useful `CellDecoder` instances:

```scala
implicit val intDecoder = cellDecoder(_.toInt)
implicit val floatDecoder = cellDecoder(_.toFloat)
implicit val stringDecoder = cellDecoder(identity)
implicit val booleanDecoder = cellDecoder(_.toBoolean)
```

---

## First attempt at decoding tuples

```scala
implicit val decoder = rowDecoder { row ⇒
  (row(0).toInt, row(1), row(2).toBoolean)
}
```

--

This works:

```scala
scala> decodeCsv[(Int, String, Boolean)](input)
res12: List[(Int, String, Boolean)] = List((1,Nicolas,true), (2,Jessica,false), (3,Matt,false))
```

--

Disapointing, though: parsing of individual cells is hard-coded.

Didn't we just write a mechanism for that?

---

## Using `CellDecoder`, take 1

Naive implementation:

```scala
implicit val decoder = rowDecoder { row ⇒
  (intDecoder.decode(row(0)),
   stringDecoder.decode(row(1)),
   booleanDecoder.decode(row(2)))
}
```

--

The decoder instances are hard-coded - always a sign that things can be made more generic.

---

## Another look at implicit resolution

There's another rule used in implicit resolution:

> When the compiler looks for an implicit values of type `T` and finds a function that returns a `T` that it can call,
> it will use its return value.

Of interest to us: a function that returns a `T` and that takes implicit parameters that can all be fulfilled.

---

## Using `CellDecoder`, take 2

Better implementation:

```scala
implicit def decoder(implicit di: CellDecoder[Int],
                              ds: CellDecoder[String],
                              db: CellDecoder[Boolean]) =
  rowDecoder { row ⇒
    (di.decode(row(0)), ds.decode(row(1)), db.decode(row(2)))
  }
```

--

This produces the desired result:

```scala
scala> decodeCsv[(Int, String, Boolean)](input)
res13: List[(Int, String, Boolean)] = List((1,Nicolas,true), (2,Jessica,false), (3,Matt,false))
```

--

It works because, when looking for an implicit `RowDecoder[(Int, String, Boolean)]`, the compiler finds `decoder`, and
realises it can call it.

---

## Using `CellDecoder`, take 3

Why specialise our implicit parameters to `Int`, `String` and `Boolean`?

```scala
implicit def decoder[A, B, C](implicit da: CellDecoder[A],
                                       db: CellDecoder[B],
                                       dc: CellDecoder[C]) =
  rowDecoder { row ⇒
    (da.decode(row(0)), db.decode(row(1)), dc.decode(row(2)))
  }
```

--

Take a minute to let that sink in:

_We've written an instance of `RowDecoder[(A, B, C)]` for all `A`, `B` and `C` that have a `CellDecoder` instance_.

--

For example:

```scala
scala> decodeCsv[(Float, String, Boolean)](input)
res14: List[(Float, String, Boolean)] = List((1.0,Nicolas,true), (2.0,Jessica,false), (3.0,Matt,false))
```

---

## Optional cells

Sometimes, CSV cells are absent or empty:

```scala
scala> val input = "1,Nicolas,true\n,Jessica,false\n3,Matt,false"
input: String =
1,Nicolas,true
,Jessica,false
3,Matt,false
```

--

This is what `Option` is made for.

```scala
implicit def optionCellDecoder[A](implicit da: CellDecoder[A]) = cellDecoder {
  case "" ⇒ None
  case s  ⇒ Some(da.decode(s))
}
```

---

## Optional cells (2)

This yields the expected result:

```scala
scala> decodeCsv[(Option[Int], String, Boolean)](input)
res15: List[(Option[Int], String, Boolean)] = List((Some(1),Nicolas,true), (None,Jessica,false), (Some(3),Matt,false))
```

--

_We've written an instance of `CellDecoder[Option[A]]` for any `A` that has a `CellDecoder` instance._

---

## Cells with multiple types

"Sometimes", CSV data is messy:

```scala
scala> val input = "1,Nicolas,true\n2,Jessica,36"
input: String =
1,Nicolas,true
2,Jessica,36
```

--

We have `Either` to represent these cases:

```scala
implicit def eitherCellDecoder[A, B](implicit da: CellDecoder[A],
                                              db: CellDecoder[B]) =
  cellDecoder { s ⇒
    try {Left(da.decode(s))}
    catch { case _: Throwable ⇒ Right(db.decode(s)) }
  }
```

---

## Cells with multiple types (2)

This yields the expected result:

```scala
scala> decodeCsv[(Int, String, Either[Boolean, Int])](input)
res16: List[(Int, String, Either[Boolean,Int])] = List((1,Nicolas,Left(true)), (2,Jessica,Right(36)))
```

--

_We've written an instance of `CellDecoder[Either[A, B]]` for all `A` and `B` that have a `CellDecoder` instance._

---

## Complex compositions

```scala
scala> val input = "1,Nicolas,true\nfalse,Jessica,false\n,Matt,false"
input: String =
1,Nicolas,true
false,Jessica,false
,Matt,false
```

The first column looks like an `Option[Either[Int, Boolean]]`.

--

We already have `Either` and `Option` instances, so we get this for free:

```scala
scala> decodeCsv[(Option[Either[Int, Boolean]], String, Boolean)](input)
res17: List[(Option[Either[Int,Boolean]], String, Boolean)] = List((Some(Left(1)),Nicolas,true), (Some(Right(false)),Jessica,false), (None,Matt,false))
```



---

## Collections of values

We have lost the ability to decode a row as `List[Int]` on the way:

```scala
val input = "1,2,3\n4,5,6\n7,8,9"
```

--

Warning - uses `CanBuildFrom`

--

```scala
import scala.collection.generic.CanBuildFrom

implicit def collectionDecoder[A, C[_]]
               (implicit da: CellDecoder[A],
                         cbf: CanBuildFrom[Nothing, A, C[A]]) =
  rowDecoder(_.foldLeft(cbf.apply()) { (out, s) ⇒
    out += da.decode(s)
  }.result())
```

---

## Collections of values (2)

This yields the expected result, for any collection type:

```scala
scala> decodeCsv[List[Int]](input)
res19: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))
```

```scala
scala> decodeCsv[Vector[Int]](input)
res20: List[Vector[Int]] = List(Vector(1, 2, 3), Vector(4, 5, 6), Vector(7, 8, 9))
```

```scala
scala> decodeCsv[Array[Int]](input)
res21: List[Array[Int]] = List(Array(1, 2, 3), Array(4, 5, 6), Array(7, 8, 9))
```

--

_We've written an instance of `RowDecoder[F[A]]` for any collection `F` and any `A` that has a `CellDecoder` instance._

---

## Case classes

We *could* write a `RowDecoder[A]` instance for any case class `A`…

--

… but I'd have to use [shapeless](http://shapeless.io), and this would turn into a different talk entirely.

---

## Conclusions

Type classes:
* are great at adding new features to existing types

```scala
implicit val uuidDecoder = cellDecoder(java.util.UUID.fromString)
```

--

* compose implicitly, without having to write any type specific code

```scala
scala> implicitly[RowDecoder[List[Either[Int, Option[Either[Boolean, java.util.UUID]]]]]]
res22: RowDecoder[List[Either[Int,Option[Either[Boolean,java.util.UUID]]]]] = $anon$1@555053d5
```

---

## More information

Find me on Twitter ([`@NicolasRinaudo`](https://twitter.com/NicolasRinaudo)).

Make fun of my code on Github ([`nrinaudo`](https://github.com/nrinaudo/)).

See [kantan.csv](http://nrinaudo.github.io/kantan.csv/) for a concrete, usable implementation.

Get in touch with [`ioSquare`](http://iosquare.com), we're always on the lookout for Scala talent.




---
class: center, middle

# Thanks!

    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
        highlightStyle: 'solarized-dark'
      });
    </script>
  </body>
</html>
